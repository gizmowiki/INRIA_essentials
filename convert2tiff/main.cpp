// DTK
#include <dtkCore/dtkPluginManager.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkLog/dtkLog.h>

// SUP
#include <supCore/supAbstractData.h>
#include <supCore/supDataImage.h>
#include <supCore/supAbstractProcessDataFlowWriter.h>
#include <supCore/supAbstractProcessDataFlowReader.h>
#include <supCore/supAbstractProcessFrameToFrameTracker.h>
#include <supCore/supAbstractProcessGlobalTracker.h>
#include <supCore/supAbstractProcessDepthSegmentation.h>
#include <supCore/supAbstractProcessAcquisition.h>
#include <supCore/supDataPhysicalObject.h>
#include <supCore/supAbstractProcessXMLReaderWriter.h>
#include <supCore/supViewRGBD.h>

// Qt
#include <QDateTime>
#include <QDir>

// OpenCV
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp> // for resize

// STD
#include <vector>
#include <map>
#include <iostream>
#include <algorithm>

// Handle time
#include <time.h>
#include <sys/time.h>
#include <unistd.h>

#ifdef __MACH__
#include <mach/clock.h>
#include <mach/mach.h>
#endif

std::string g_ListContextualZonesRemovedPlanComputation     =   "";
using PhysicalObjs = QList< QSharedPointer< supDataPhysicalObject > >;

using namespace std;

//Mat frame; //current frame
//Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
//int keyboard; //input from keyboard

//void processImages(char* firstFrameFilename);

//bool reader_GetTimeStampFromString(char *stamp_string, int &year, int &month, int &day, int &hour, int &minute, int &second, int &millisecond);

int main(int argc, char **argv)
{
    bool CONVERT = false;
    bool COMPARE = false;
    if(argc<2){
        std::cout << "You need to provide:" << std::endl;
        std::cout << "\t-the path where you saved the files" << std::endl;
        return 1;
    }
    QString option = argv[1];
    if (option == "-convert")
    {
       CONVERT = true;
    }
    if(option == "-compare")
    {
       COMPARE = true;
    }
        QString filesPath;
        QString pathSaved;
        filesPath = argv[2];
        pathSaved = argv[3];
//        if (CONVERT)
//        {

//        }
        //QString background = argv[2];
        int start = std::stoi(argv[4]);
        //cv::Mat background_mat = cv::imread(background.toStdString(), CV_LOAD_IMAGE_ANYDEPTH);
        QApplication application(argc, argv);

        // DTK Log
        dtkLogger::instance().setLevel(dtkLog::Info);
        dtkLogger::instance().attachConsole();

        // DTK Load Plugins
        dtkPluginManager::instance()->initialize();

        // SUP Abstract Process
        supAbstractProcessDataFlowReader *  dataFlowReader    = static_cast< supAbstractProcessDataFlowReader * >( dtkAbstractProcessFactory::instance()->create("DepthCompressorProcessDataFlowReader") );

        //sup view
        supViewRGBD view;
        view.widget()->setWindowTitle("Display");
        view.show();




        //Application variables and initialization

        CSynchronizer sync;


        // Images
        cv::Mat imageMat;
        cv::Mat depthMat;


        QSharedPointer<supDataImage> l_depth,l_color;
        l_depth = QSharedPointer<supDataImage>(new supDataImage);
        l_color = QSharedPointer<supDataImage>(new supDataImage);

        unsigned int frameNumber = start;

        QDir dir;

        supAbstractData * data_i, * data_ii ;
        supDataImage * data_r, * data_rr;
        QList< supAbstractData * > * dataList;

        dataFlowReader->setDir(filesPath);
        dataFlowReader->readArgs(argc, argv);

        qDebug() << "\n the directory" << dataFlowReader->getDir();

        dir.setPath(filesPath);

        int debug=0;
        int n_files = 1;

        while(n_files  > 0)
        {
        if(debug==1) { printf("reader - read list of data\n"); }

            dataList = dataFlowReader->getDataFlow();

        if(dataFlowReader->HasReachedWantedStartTime()==false) { continue; }
        if(dataFlowReader->HasReachedWantedStopTime()==true) { break; }

            data_ii= dataList->last();
            data_rr = static_cast<supDataImage*>(data_ii);
        imageMat = data_rr->getImage();
            //cv::imshow("RGB DISPLAY", data_rr->getImage());

            data_i= dataList->first();
            data_r = static_cast<supDataImage*>(data_i);
            depthMat = data_r->getImage();
            //char name[1024];
            //dataFlowReader->get_rgb_full_filename(name);
            //cv::imwrite((pathSaved+"/depth/" +"/background.tiff").toStdString(), depthMat);
            if (CONVERT)
            {
              cv::imwrite((pathSaved + "/" + QString("%1").arg(frameNumber,6,10,QLatin1Char('0')) + ".tiff").toStdString(), depthMat);
              cv::imwrite((pathSaved + "/" + QString("%1").arg(frameNumber,6,10,QLatin1Char('0')) + ".jpg").toStdString(), imageMat);
            }
            if (COMPARE)
            {
                cv::Mat tiffMap;
                tiffMap = cv::imread((pathSaved + "/" + QString("%1").arg(frameNumber,3,10,QLatin1Char('0')) + ".tiff").toStdString(), CV_LOAD_IMAGE_ANYDEPTH);
                bool eq = std::equal(depthMat.begin<ushort>(), depthMat.end<ushort>(), tiffMap.begin<ushort>());
                if(eq)
                    std::cout << "IMAGE IS CONSERVERED ------------------------";
                else
                    std::cout << "IMAGE IS NOT NOT CONSERVERED ------------------------";

            }
    //        for(int i=0; i<depthMat.rows; i++)
    //            for(int j=0; j<depthMat.cols; j++)
    //            {
    //                ushort pd = depthMat.at<ushort>(i,j);
    //                ushort pb = background_mat.at<ushort>(i,j);
    //                ushort t = 0;
    //                if(pd - pb < 0)
    //                    t = pb - pd;
    //                if (t > threshold)
    //                    t = 65535;
    //                else
    //                    t = 0;
    //                depthMat.at<ushort>(i,j) = t;
    ////                if(pb > pd + threshold)
    ////                {
    ////                    depthMat.at<ushort>(i,j) = 65535;
    ////                }
    //            }

            sync = dataFlowReader->getSynchronizer();
            sync.setFrameNumber(frameNumber);
            //cv::imshow("BST",depthMat);


            frameNumber++;

            cv::Mat bgrImage( data_rr->getImage() );
            cv::Mat depthMat( data_r->getImage() );
            l_color->setImage(bgrImage);
            l_depth->setImage(depthMat);
            view.setAcquisitionImage(l_color);
            view.setAcquisitionDepth(l_depth);
            view.updateDisplay();

            //cv::imshow("RGB DISPLAY", imageMat);
            application.processEvents();

            char c = cvWaitKey(30);
            if(c==27) break;

        }

        dtkPluginManager::instance()->uninitialize();





    return 0;
}


#define reader_Closest_bis(x) ((x)<0?(int)((x)-0.5):(int)((x)+0.5))
int reader_Power(int a, int b) { return reader_Closest_bis( pow((double)(a) ,(double)(b)) ); }
int reader_GetIntFromString(char *string)
{
	int len = strlen(string);
	int out = 0; int negative = 0;
	for(int i=0; i<len; i++)
	{
		if(i==0 && string[i]=='-'){ negative=1; }
		else
		{
			int digit=-1;
			if(string[i]=='0') { digit=0; }
			else if(string[i]=='1') { digit=1; }
			else if(string[i]=='2') { digit=2; }
			else if(string[i]=='3') { digit=3; }
			else if(string[i]=='4') { digit=4; }
			else if(string[i]=='5') { digit=5; }
			else if(string[i]=='6') { digit=6; }
			else if(string[i]=='7') { digit=7; }
			else if(string[i]=='8') { digit=8; }
			else if(string[i]=='9') { digit=9; }
			else {
				printf(" ---ERROR--- PROBLEM IN GetIntFromString(..) -> NOT A INTEGER IN STRING '%s'\n", string);
				getchar();
				return -1;
			}
			out += digit*reader_Power(10, len-1-i);
		}
	}
	if(negative==1) { out = out * (-1); }
	return out;
}
bool reader_GetTimeStampFromString(char *stamp_string, int &year, int &month, int &day, int &hour, int &minute, int &second, int &millisecond)
{
	year=month=day=hour=minute=second=millisecond=0;
	printf("extract stamp param from string '%s'\n", stamp_string);
	int len = strlen(stamp_string);
	char str[10];
	if(len>=4) { for(int i=0; i<4; i++) { str[i] = stamp_string[i]; } str[4]='\0'; year = reader_GetIntFromString(str); }
	if(len>=7) { for(int i=0; i<2; i++) { str[i] = stamp_string[5+i]; } str[2]='\0'; month = reader_GetIntFromString(str); }
	if(len>=10){ for(int i=0; i<2; i++) { str[i] = stamp_string[8+i]; } str[2]='\0'; day = reader_GetIntFromString(str); }
	if(len>=13){ for(int i=0; i<2; i++) { str[i] = stamp_string[11+i]; } str[2]='\0'; hour = reader_GetIntFromString(str); }
	if(len>=16){ for(int i=0; i<2; i++) { str[i] = stamp_string[14+i]; } str[2]='\0'; minute = reader_GetIntFromString(str); }
	if(len>=19){ for(int i=0; i<2; i++) { str[i] = stamp_string[17+i]; } str[2]='\0'; second = reader_GetIntFromString(str); }
	if(len>=24){ for(int i=0; i<3; i++) { str[i] = stamp_string[20+i]; } str[3]='\0'; millisecond = reader_GetIntFromString(str); }
	return true;
}


